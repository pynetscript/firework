---
- name: Post-Check Firewall Rule Configuration
  hosts: "{{ firewalls | join(',') }}" # Dynamically target firewalls passed from Flask app
  gather_facts: no
  connection: network_cli # Default for Cisco, adjust for FortiGate/Palo Alto if needed per task
  collections:
    - cisco.ios
    - fortinet.fortios
    - paloaltonetworks.panos

  vars:
    rule_id: "{{ rule_id }}"
    source_ip: "{{ source_ip }}"
    destination_ip: "{{ destination_ip }}"
    protocol: "{{ protocol }}"
    dest_port: "{{ dest_port }}" # Use 'dest_port' consistently

    # Map protocol names to numbers for Palo Alto `test security-policy-match` command
    # Ensures 'any' protocol doesn't cause an error if it's not a key in the dict
    pa_protocol_number: "{{ { 'tcp': 6, 'udp': 17, 'icmp': 1 }.get(protocol | lower, protocol) }}"

  tasks:
    - name: Debug Post-Check variables
      debug:
        msg: "Post-checking Rule ID: {{ rule_id }}, Source: {{ source_ip }}, Dest: {{ destination_ip }}, Proto: {{ protocol }}, Port: {{ dest_port }}, Firewalls: {{ firewalls }}"

    # --- FortiGate Post-Check Example (Verify policy existence) ---
    - name: Verify FortiGate Firewall Policy
      fortinet.fortios.fortios_firewall_policy:
        vdom: "root"
        state: info # Use state=info to retrieve policy details
        policyid: "{{ rule_id }}"
      register: policy_info
      when: inventory_hostname in groups['fortinet'] | default([])
      ignore_errors: yes

    - name: Check if FortiGate policy exists
      fail:
        msg: "FortiGate policy {{ rule_id }} not found or incorrect on {{ inventory_hostname }}!"
      when:
        - inventory_hostname in groups['fortinet'] | default([])
        - not policy_info.meta.results # Check if results are empty or not found
      ignore_errors: yes

    # --- Palo Alto Post-Check Example (Verify security rule existence using policy match) ---
    - name: Run Palo Alto Security Policy Match for Post-Check
      paloaltonetworks.panos.panos_op:
        provider:
          ip_address: "{{ ansible_host }}"
          username: "{{ ansible_user }}"
          password: "{{ ansible_password }}"
          api_key: "{{ ansible_api_key | default(omit) }}"
        # Conditionally include protocol if it's not 'any'
        cmd: "<test><security-policy-match><source>{{ source_ip }}</source><destination>{{ destination_ip }}</destination>{% if protocol | lower != 'any' %}<protocol>{{ pa_protocol_number }}</protocol>{% endif %}<destination-port>{{ dest_port }}</destination-port></security-policy-match></test>"
        cmd_is_xml: true
      register: pa_post_check_output
      when: inventory_hostname in groups['paloalto'] | default([])
      ignore_errors: yes

    - name: Debug Palo Alto Post-Check Output
      debug:
        var: pa_post_check_output
      when: inventory_hostname in groups['paloalto'] | default([]) and pa_post_check_output is defined

    - name: Check if Palo Alto security rule matches (Post-Check)
      fail:
        msg: "Palo Alto security rule for Rule ID {{ rule_id }} not found or incorrect on {{ inventory_hostname }} during post-check! Output: {{ pa_post_check_output.stdout_xml | default('N/A') }}"
      when: >- # Using '>-' to allow multi-line scalar string for the condition
        inventory_hostname in groups['paloalto'] | default([]) and
        pa_post_check_output is defined and
        pa_post_check_output.stdout_xml is defined and
        ( (not (pa_post_check_output.stdout_xml | regex_search('<entry name="firework-{{ rule_id }}"'))) or
          (pa_post_check_output.stdout_xml | regex_search('<entry name="No matching rule found"')) )
      ignore_errors: yes

    # Note: For a real post-check, you'd parse the output more thoroughly
    # to ensure all parameters (src/dst/proto/dest_port) match the requested rule.
    # The 'fail' module will cause the playbook to fail if the condition is met,
    # which will be caught by subprocess.CalledProcessError in Flask.
